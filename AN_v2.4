javascript:(function () {
  'use strict';

  const $ = window.jQuery;
  if (!$) { alert('KZ: chyb√≠ jQuery (nejsi v hern√≠m UI?)'); return; }

  const ScriptData = { name: "KZ ‚Äì Auto pozn√°mky z oznamky (CZ)", version: "v0.3.2-spy-vs-off-attack-mode" };
  const T = {
    verifyReportPage: "Skript mus√≠≈° spustit v detailu oznamky (report).",
    noteCreated: "Pozn√°mka ulo≈æena",
    noteOverwritten: "Pozn√°mka p≈ôeps√°na (v√≠c odhaleno)",
    noteAppended: "Pozn√°mka doplnƒõna (intel zachov√°n)",
    chooseSide: "Zapsat report ke kter√© vesnici?",
    attacker: "√ötoƒçn√≠k",
    defender: "Obr√°nce",
    unknown: "Nezn√°m√©",
    offensive: "Off",
    defensive: "Deff",
    probOffensive: "Sp√≠≈° off",
    probDefensive: "Sp√≠≈° deff",
    spyDefensive: "Deff/≈°peh",
    noSurvivors: "Nic nep≈ôe≈æilo",
    sent: "Poslal",
    died: "Padlo",
    survived: "P≈ôe≈æilo",
    home: "Mƒõl doma",
    away: "Mƒõl mimo",
    upgrades: "Vylep≈°en√≠",
    siegeDamage: "≈†koda obl√©h√°n√≠m",
    noDefenderUnits: "Obr√°nce: jednotky nezji≈°tƒõny",
    attackOn: "√ötok na",
    died100: "Padlo (100%)",
  };

  const UI = window.UI;
  const Dialog = window.Dialog;
  const Timing = window.Timing;

  const GD = window.game_data;
  const ME = GD?.player?.name ? String(GD.player.name) : '';
  const sitter = String(GD?.player?.sitter ?? '0') !== '0';

  const UNIT_KEYS = Array.isArray(GD?.units) && GD.units.length
    ? GD.units.filter(u => u !== 'militia')
    : ['spear','sword','axe','spy','light','heavy','ram','catapult','snob'];

  const UNIT_POP = {
    spear: 1,
    sword: 1,
    axe: 1,
    archer: 1,
    spy: 2,
    light: 4,
    marcher: 5,
    heavy: 6,
    ram: 5,
    catapult: 8,
    knight: 10,
    snob: 100,
  };

  // Jemn√© doladƒõn√≠ merge logiky mezi svƒõty
  const KZ_MERGE_TUNING = {
    GAP_HOURS: 12,                // max ƒças mezi reporty, aby to byl st√°le 'stejn√Ω kontext arm√°dy'
    SAME_ARMY_OVERLAP: 0.75,      // 0..1, jak moc se mus√≠ arm√°dy p≈ôekr√Ωvat, aby byly br√°ny jako stejn√° arm√°da
    OLD_SURVIVED_MIN_RATIO: 0.90, // star√Ω report: min pod√≠l p≈ôe≈æiv≈°√≠ch z poslan√Ωch, aby to bylo 'off pro≈°la'
    OLD_LOSS_MAX_RATIO: 0.15,     // star√Ω report: max pod√≠l ztr√°t, aby to st√°le byla pr≈Øchoz√≠ off
    MIN_OLD_SENT_TOTAL: 1000,     // cleanup ≈ôe≈°√≠me jen u vƒõt≈°√≠ch arm√°d (omez√≠ fale≈°n√© maz√°n√≠ mal√Ωch √∫tok≈Ø)
    REQUIRE_NEW_OFF_TAG: true,    // nov√Ω report mus√≠ b√Ωt tak√© "off", jinak star√Ω block nema≈æeme
  };

  const KZ_CLASSIFY = {
    FULL_OFF_POP: 22000, // referenƒçn√≠ velikost pln√© offky pro score 1.0
  };

  function verifyReportPage() {
    const m = window.location.href.match(/screen=report|view=report|screen=report_view|mode=report/);
    if (!m) { UI.ErrorMessage(T.verifyReportPage, 5000); return false; }
    if (!$('#attack_info_att').length || !$('#attack_info_def').length) { UI.ErrorMessage(T.verifyReportPage, 5000); return false; }
    return true;
  }

  function kz_getBattleDateText() {
    const rows = Array.from(document.querySelectorAll('#content_value table.vis tr'));
    for (const tr of rows) {
      const tds = tr.querySelectorAll('td');
      if (tds.length < 2) continue;
      const key = (tds[0].textContent || '').replace(/\s+/g, ' ').trim();
      if (key !== 'ƒåas boje') continue;
      const td = tds[1].cloneNode(true);
      td.querySelectorAll('span').forEach(s => s.remove());
      const raw = (td.textContent || '').replace(/\u00a0/g, ' ').replace(/\s+/g, ' ').trim();
      return raw || 'ƒças boje nezn√°m√Ω';
    }
    return 'ƒças boje nezn√°m√Ω';
  }

  function kz_isReportOverviewPage() {
    return !!document.querySelector('#report_list');
  }

  function kz_getSelectedReportUrlsFromOverview() {
    const rows = Array.from(document.querySelectorAll('#report_list tr'));
    const out = [];
    for (const tr of rows) {
      const cb = tr.querySelector('input[type="checkbox"][name^="id_"]:checked');
      if (!cb) continue;
      const a = tr.querySelector('a.report-link[href*="view="]');
      if (!a) continue;
      const href = a.getAttribute('href');
      if (!href) continue;
      const url = href.startsWith('http') ? href : (location.origin + href);
      out.push(url);
    }
    return out;
  }

  function kz_parseBattleDateToMs(s) {
    if (!s) return NaN;
    const txt = String(s).trim();
    const m = txt.match(/^(\d{1,2})\.(\d{1,2})\.(\d{2}|\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?/);
    if (!m) return NaN;

    const dd = parseInt(m[1], 10);
    const mm = parseInt(m[2], 10);
    let yy = parseInt(m[3], 10);
    const hh = parseInt(m[4], 10);
    const mi = parseInt(m[5], 10);
    const ss = parseInt(m[6] || '0', 10);

    if (!Number.isFinite(dd) || !Number.isFinite(mm) || !Number.isFinite(yy) ||
        !Number.isFinite(hh) || !Number.isFinite(mi) || !Number.isFinite(ss)) return NaN;
    if (yy < 100) yy = 2000 + yy;

    const d = new Date(yy, mm - 1, dd, hh, mi, ss, 0);
    const ms = d.getTime();
    return Number.isFinite(ms) ? ms : NaN;
  }

  function calcOffDeffFarm(vec) {
    let off = 0, deff = 0;
    for (let i = 0; i < vec.length; i++) {
      const n = vec[i] || 0;
      const unit = UNIT_KEYS[i];
      const pop = UNIT_POP[unit] || 0;
      if (unit === 'axe' || unit === 'light' || unit === 'marcher' || unit === 'ram' || unit === 'catapult') off += n * pop;
      if (unit === 'spear' || unit === 'sword' || unit === 'archer' || unit === 'heavy' || unit === 'knight') deff += n * pop;
    }
    return { off, deff };
  }

  function classify(vec) {
    const { off, deff } = calcOffDeffFarm(vec);
    if (!vec.some(v => v > 0)) return { text: T.noSurvivors, color: '#888888', score: 0.0, tag: 'mix' };

    const spyIdx = Math.max(0, UNIT_KEYS.indexOf('spy'));
    const spyCount = vec[spyIdx] || 0;
    const total = vec.reduce((a, b) => a + (b || 0), 0);
    const nonSpy = Math.max(0, total - spyCount);

    // anti-fale≈°n√° "off" klasifikace pro ƒçistƒõ/hlavnƒõ ≈°pehovac√≠ reporty
    if (spyCount >= 200 && spyCount >= nonSpy * 1.2 && off < (KZ_CLASSIFY.FULL_OFF_POP * 0.25)) {
      const score = Math.round(Math.min(1, spyCount / 4000) * 10) / 10;
      return { text: T.spyDefensive, color: '#2b7bb9', score, tag: 'deff' };
    }

    const offScore = Math.min(1, off / KZ_CLASSIFY.FULL_OFF_POP);
    const deffScore = Math.min(1, deff / 20000);

    if (off > deff) {
      const score = Math.round(offScore * 10) / 10;
      const text = (offScore >= 0.55) ? T.offensive : T.probOffensive;
      return { text, color: '#ff0000', score, tag: 'off' };
    } else {
      const score = Math.round(deffScore * 10) / 10;
      const text = (deff > 1000) ? T.defensive : T.probDefensive;
      return { text, color: '#0eae0e', score, tag: 'deff' };
    }
  }

  function parseVecFromUnitsTable(tableSel, rowIndex1based) {
    const tds = $(`${tableSel} > tbody > tr:nth-child(${rowIndex1based}) > td.unit-item`);
    if (!tds.length) return null;
    const vec = [];
    tds.each((i, el) => {
      if (i < UNIT_KEYS.length) vec[i] = parseInt((el.textContent || '0').trim(), 10) || 0;
    });
    while (vec.length < UNIT_KEYS.length) vec.push(0);
    return vec;
  }

  function vecSub(a, b) {
    const out = [];
    for (let i = 0; i < Math.max(a.length, b.length); i++) out[i] = Math.max(0, (a[i] || 0) - (b[i] || 0));
    return out;
  }

  function vecEqual(a, b) {
    for (let i = 0; i < Math.max(a.length, b.length); i++) if ((a[i] || 0) !== (b[i] || 0)) return false;
    return true;
  }

  function isAllZero(vec) {
    if (!vec) return true;
    for (const n of vec) if ((n|0) !== 0) return false;
    return true;
  }

  function kz_fmtLabelStyled(label) {
    if (label === T.home) return `[color=#1976d2]${label}[/color]`;
    if (label === T.away) return `[color=#7b1fa2]${label}[/color]`;
    if (label === T.died || label === T.died100) return `[color=#d32f2f]${label}[/color]`;
    if (label === T.survived) return `[color=#2e7d32]${label}[/color]`;
    return label;
  }

  function fmtUnitsOnly(vec) {
    const parts = [];
    for (let i = 0; i < UNIT_KEYS.length; i++) {
      const n = vec[i] || 0;
      if (n > 0) parts.push(`[unit]${UNIT_KEYS[i]}[/unit] ${n}`);
    }
    return parts.length ? parts.join(' ') : '‚Äî';
  }

  function fmtLine(label, vec) {
    return `[b]${kz_fmtLabelStyled(label)}:[/b] ${fmtUnitsOnly(vec)}`;
  }


  function getNamesAndVillageIds() {
    const attName = $('#attack_info_att > tbody > tr:nth-child(1) > th:nth-child(2) > a').text().trim();
    const defName = $('#attack_info_def > tbody > tr:nth-child(1) > th:nth-child(2) > a').text().trim();

    const attHref = $('#attack_info_att > tbody > tr:nth-child(2) > td:nth-child(2) a[href*="screen=info_village"][href*="id="]').attr('href') || '';
    const defHref = $('#attack_info_def > tbody > tr:nth-child(2) > td:nth-child(2) a[href*="screen=info_village"][href*="id="]').attr('href') || '';

    const attId = (attHref.match(/[?&]id=(\d+)/) || [])[1] || '-1';
    const defId = (defHref.match(/[?&]id=(\d+)/) || [])[1] || '-1';

    const attCoord = ($('#attack_info_att').text().match(/(\d{3}\|\d{3})/) || [])[1] || '';
    const defCoord = ($('#attack_info_def').text().match(/(\d{3}\|\d{3})/) || [])[1] || '';

    return { attName, defName, attId, defId, attCoord, defCoord };
  }

  function kz_parseUnitsFromLine(line) {
    const re = /\[unit\]([a-z]+)\[\/unit\]\s*([0-9]+)/gi;
    const out = Object.create(null);
    let m;
    while ((m = re.exec(line))) {
      out[m[1]] = (out[m[1]] || 0) + parseInt(m[2], 10);
    }
    return out;
  }

  function kz_sumObj(o) {
    let s = 0;
    for (const k in o) s += o[k] || 0;
    return s;
  }

  function kz_mergeUnitObjs(a, b) {
    const out = Object.assign(Object.create(null), a || {});
    for (const k in (b || {})) out[k] = (out[k] || 0) + (b[k] || 0);
    return out;
  }

  function kz_extractMostRecentIntelBlock(noteText) {
    if (!noteText) return null;

    const lines = noteText.split(/\r?\n/);
    const markers = ['Mƒõl doma', 'Mƒõl mimo', 'Poslal', 'Padlo', 'P≈ôe≈æilo'];

    let firstIdx = -1;
    for (let i = 0; i < lines.length; i++) {
      const L = lines[i];
      if (markers.some(m => L.includes(m))) { firstIdx = i; break; }
    }
    if (firstIdx === -1) return null;

    const end = Math.min(lines.length, firstIdx + 14);
    const blockLines = lines.slice(0, end);
    const block = blockLines.join('\n');

    const intel = {
      home: Object.create(null),
      away: Object.create(null),
      sent: Object.create(null),
      died: Object.create(null),
      surv: Object.create(null),
    };

    for (const ln of blockLines) {
      if (ln.includes('Mƒõl doma')) intel.home = kz_mergeUnitObjs(intel.home, kz_parseUnitsFromLine(ln));
      if (ln.includes('Mƒõl mimo')) intel.away = kz_mergeUnitObjs(intel.away, kz_parseUnitsFromLine(ln));
      if (ln.includes('Poslal')) intel.sent = kz_mergeUnitObjs(intel.sent, kz_parseUnitsFromLine(ln));
      if (ln.includes('Padlo')) intel.died = kz_mergeUnitObjs(intel.died, kz_parseUnitsFromLine(ln));
      if (ln.includes('P≈ôe≈æilo')) intel.surv = kz_mergeUnitObjs(intel.surv, kz_parseUnitsFromLine(ln));
    }

    const revealed =
      kz_sumObj(intel.home) +
      kz_sumObj(intel.away) +
      kz_sumObj(intel.sent) +
      kz_sumObj(intel.died) +
      kz_sumObj(intel.surv);

    return { blockText: block, intel, revealed };
  }

  async function kz_fetchVillageNoteText(villageId) {
    const url = `game.php?screen=info_village&id=${encodeURIComponent(villageId)}`;
    const html = await (await fetch(url, { credentials: 'include' })).text();
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const ta = doc.querySelector('textarea[name="note"], textarea#note, textarea');
    return ta ? (ta.value || ta.textContent || '') : '';
  }

  // --- NOV√â: maz√°n√≠ zastaral√© info "pln√° off bez ztr√°t" ---
  function kz_getLineByLabel(blockText, label) {
    if (!blockText) return '';
    const lines = blockText.split(/\r?\n/);
    return lines.find(l => l.includes(label)) || '';
  }


  function kz_blockLooksOff(blockText) {
    return /\[b\]\s*\d+(?:[\.,]\d+)?\s+off\s*\[\/b\]/i.test(blockText || '');
  }

  function kz_getBattleDateFromBlock(blockText) {
    const first = String((blockText || '').split(/\r?\n/)[0] || '');
    const m = first.match(/\[b\]([^\[]+)\[\/b\]/i);
    return m ? String(m[1]).trim() : '';
  }

  function kz_parseBlockDateToMs(blockText) {
    return kz_parseBattleDateToMs(kz_getBattleDateFromBlock(blockText));
  }

  function kz_splitIntelBlocks(noteText) {
    if (!noteText) return [];
    return noteText
      .split(/\n{2,}/)
      .map(s => s.trim())
      .filter(s => s && /(Mƒõl doma|Mƒõl mimo|Poslal|Padlo|P≈ôe≈æilo)/.test(s));
  }

  function kz_objMinSum(a, b) {
    const keys = new Set([...Object.keys(a || {}), ...Object.keys(b || {})]);
    let s = 0;
    for (const k of keys) s += Math.min(a?.[k] || 0, b?.[k] || 0);
    return s;
  }

  function kz_looksLikeSameArmy(oldSent, newArmy) {
    const oldSum = kz_sumObj(oldSent);
    const newSum = kz_sumObj(newArmy);
    if (oldSum <= 0 || newSum <= 0) return false;

    const overlap = kz_objMinSum(oldSent, newArmy);
    const overlapVsOld = overlap / oldSum;
    const overlapVsNew = overlap / newSum;
    return overlapVsOld >= KZ_MERGE_TUNING.SAME_ARMY_OVERLAP || overlapVsNew >= KZ_MERGE_TUNING.SAME_ARMY_OVERLAP;
  }

  function kz_isOffGoneTransition(oldBlockText, newBlockText) {
    const oldSent = kz_parseUnitsFromLine(kz_getLineByLabel(oldBlockText, 'Poslal'));
    const oldDied = kz_parseUnitsFromLine(kz_getLineByLabel(oldBlockText, 'Padlo'));
    const oldSurv = kz_parseUnitsFromLine(kz_getLineByLabel(oldBlockText, 'P≈ôe≈æilo'));

    const oldSentSum = kz_sumObj(oldSent);
    const oldDiedSum = kz_sumObj(oldDied);
    const oldSurvSum = kz_sumObj(oldSurv);

    const oldLossRatio = oldSentSum > 0 ? (oldDiedSum / oldSentSum) : 1;
    const oldSurvRatio = oldSentSum > 0 ? (oldSurvSum / oldSentSum) : 0;

    const hadStrongOffSurvival =
      oldSentSum > 0 &&
      kz_blockLooksOff(oldBlockText) &&
      oldSurvRatio >= KZ_MERGE_TUNING.OLD_SURVIVED_MIN_RATIO &&
      oldLossRatio <= KZ_MERGE_TUNING.OLD_LOSS_MAX_RATIO;

    if (!hadStrongOffSurvival) return false;
    if (oldSentSum < KZ_MERGE_TUNING.MIN_OLD_SENT_TOTAL) return false;

    if (KZ_MERGE_TUNING.REQUIRE_NEW_OFF_TAG && !kz_blockLooksOff(newBlockText)) return false;

    const newSent = kz_parseUnitsFromLine(kz_getLineByLabel(newBlockText, 'Poslal'));
    const newDied = kz_parseUnitsFromLine(kz_getLineByLabel(newBlockText, 'Padlo'));
    const newSurv = kz_parseUnitsFromLine(kz_getLineByLabel(newBlockText, 'P≈ôe≈æilo'));
    const newDied100 = kz_parseUnitsFromLine(kz_getLineByLabel(newBlockText, 'Padlo (100%)'));

    const newShowsLoss =
      kz_sumObj(newDied) > 0 ||
      kz_sumObj(newDied100) > 0 ||
      (kz_sumObj(newSent) > 0 && kz_sumObj(newSurv) < kz_sumObj(newSent));

    if (!newShowsLoss) return false;

    // Opatrnost proti fale≈°n√Ωm p≈ôepis≈Øm:
    // - star√Ω report mus√≠ vypadat jako 'off pro≈°la' (vysok√© p≈ôe≈æit√≠, n√≠zk√© ztr√°ty),
    // - mus√≠ j√≠t o relativnƒõ ƒçerstvƒõj≈°√≠ boj (typicky stejn√° vlna),
    // - arm√°da mus√≠ vypadat jako stejn√° (overlap podle KZ_MERGE_TUNING.SAME_ARMY_OVERLAP),
    const oldMs = kz_parseBlockDateToMs(oldBlockText);
    const newMs = kz_parseBlockDateToMs(newBlockText);
    if (Number.isFinite(oldMs) && Number.isFinite(newMs)) {
      const diff = newMs - oldMs;
      const maxGapMs = KZ_MERGE_TUNING.GAP_HOURS * 60 * 60 * 1000;
      if (diff <= 0 || diff > maxGapMs) return false;
    }

    const newArmyRef = kz_sumObj(newDied100) > 0 ? newDied100 : (kz_sumObj(newSent) > 0 ? newSent : newDied);
    if (!kz_looksLikeSameArmy(oldSent, newArmyRef)) return false;

    return true;
  }

  function kz_removeStaleFullOffBlocks(existing, newBlockText) {
    const blocks = kz_splitIntelBlocks(existing);
    if (!blocks.length) return { note: existing, removed: 0 };

    const kept = [];
    let removed = 0;
    for (const block of blocks) {
      if (kz_isOffGoneTransition(block, newBlockText)) {
        removed += 1;
      } else {
        kept.push(block);
      }
    }
    return { note: kept.join('\n\n').trim(), removed };
  }

  function kz_normalizeNoteBlock(text) {
    if (!text) return text;
    // hard-fix star√©ho inline form√°tu "Mƒõl doma ... | Mƒõl mimo ..."
    return String(text)
      .replace(/\s+\|\s+(\[b\](?:\[color=[^\]]+\])?Mƒõl mimo(?:\[\/color\])?:\[\/b\])/g, '\n$1');
  }

  async function kz_decideMerge(villageId, newBlockText) {
    // Hard overwrite re≈æim: v≈ædy vr√°t√≠me jen nov√Ω blok.
    // Z√°mƒõrnƒõ bez ƒçten√≠ existuj√≠c√≠ pozn√°mky, aby nemohlo doj√≠t k p≈ôim√≠ch√°n√≠ star√Ωch dat.
    return { mode: 'overwrite', note: kz_normalizeNoteBlock(newBlockText) };
  }

  function buildNoteBlock(headerInfo, lines, exportCodeOptional, attackSize) {
    const scoreTxt = (headerInfo.score ?? 0).toFixed(1);
    const battleDate = kz_getBattleDateText();
    const sizeTxt = attackSize ? `${attackSize} | ` : '';
    const head = `[b]${battleDate}[/b] | ${sizeTxt}[color=${headerInfo.color}][b]${scoreTxt} ${headerInfo.tag}[/b][/color] | [i]${headerInfo.text}[/i]`;
    return `${head}\n${lines.join('\n')}${exportCodeOptional ? `\n\n${exportCodeOptional}` : ''}`;
  }

  function buildNoteBlockWithForcedDate(headerInfo, lines, exportCodeOptional, battleDate, attackSize) {
    const scoreTxt = (headerInfo.score ?? 0).toFixed(1);
    const sizeTxt = attackSize ? `${attackSize} | ` : '';
    const head = `[b]${battleDate}[/b] | ${sizeTxt}[color=${headerInfo.color}][b]${scoreTxt} ${headerInfo.tag}[/b][/color] | [i]${headerInfo.text}[/i]`;
    return `${head}\n${lines.join('\n')}${exportCodeOptional ? `\n\n${exportCodeOptional}` : ''}`;
  }

  function apiNoteEdit(villageId, noteText) {
    const base = `https://${location.hostname}/game.php?village=${GD.village.id}&screen=api&ajaxaction=village_note_edit`;
    const url = sitter
      ? `${base}&t=${GD.player.id}`
      : `${base}&h=${GD.csrf}&client_time=${Math.round(Timing.getCurrentServerTime() / 1000)}`;

    return $.post(url, { note: noteText, village_id: villageId, h: GD.csrf });
  }

  function kz_parseVecFromUnitsTableDoc(doc, tableSel, rowIndex1based) {
    const row = doc.querySelector(`${tableSel} > tbody > tr:nth-child(${rowIndex1based})`);
    if (!row) return null;
    const tds = Array.from(row.querySelectorAll('td.unit-item'));
    if (!tds.length) return null;

    const vec = [];
    for (let i = 0; i < Math.min(tds.length, UNIT_KEYS.length); i++) {
      vec[i] = parseInt((tds[i].textContent || '0').trim(), 10) || 0;
    }
    while (vec.length < UNIT_KEYS.length) vec.push(0);
    return vec;
  }

  function kz_getBattleDateTextFromDoc(doc) {
    const rows = Array.from(doc.querySelectorAll('#content_value table.vis tr'));
    for (const tr of rows) {
      const tds = tr.querySelectorAll('td');
      if (tds.length < 2) continue;
      const key = (tds[0].textContent || '').replace(/\s+/g, ' ').trim();
      if (key !== 'ƒåas boje') continue;

      const td = tds[1].cloneNode(true);
      td.querySelectorAll('span').forEach(s => s.remove());

      const raw = (td.textContent || '').replace(/\u00a0/g, ' ').replace(/\s+/g, ' ').trim();
      return raw || 'ƒças boje nezn√°m√Ω';
    }
    return 'ƒças boje nezn√°m√Ω';
  }



  function kz_attackSizeFromDoc(doc) {
    const img = doc.querySelector('img[src*="attack_large"], img[src*="attack_medium"], img[src*="attack_small"]');
    const src = img?.getAttribute('src') || '';
    if (src.includes('attack_large')) return 'ü™ìL';
    if (src.includes('attack_medium')) return 'ü™ìM';
    if (src.includes('attack_small')) return 'ü™ìS';
    return '';
  }

  function kz_attackSizeFromPage() {
    return kz_attackSizeFromDoc(document);
  }

  function kz_isSpyReportDoc(doc) {
    return !!doc.querySelector('#attack_spy, #attack_spy_away, #attack_spy_building_data, #attack_spy_resources');
  }

  function kz_isSpyReportPage() {
    return kz_isSpyReportDoc(document);
  }

  function kz_parseSpyAwayCellsToVec(cells) {
    const vec = [];
    for (let i = 0; i < Math.min(cells.length, UNIT_KEYS.length); i++) vec[i] = parseInt((cells[i].textContent || '0').trim(), 10) || 0;
    while (vec.length < UNIT_KEYS.length) vec.push(0);
    return isAllZero(vec) ? null : vec;
  }

  function kz_parseSpyAwayVecDoc(doc) {
    const sels = [
      '#attack_spy_away td table tbody tr:nth-child(2) > td',
      '#attack_spy_away td table tr:nth-child(2) > td',
      '#attack_spy_away > tbody > tr:nth-child(2) > td:nth-child(2) table tbody tr:nth-child(2) > td',
    ];
    for (const sel of sels) {
      const tds = Array.from(doc.querySelectorAll(sel));
      if (!tds.length) continue;
      const vec = kz_parseSpyAwayCellsToVec(tds);
      if (vec) return vec;
    }
    return null;
  }

  function kz_parseSpyAwayVecPage() {
    return kz_parseSpyAwayVecDoc(document);
  }


  function kz_cleanTextLines(raw) {
    return String(raw || '')
      .replace(/\u00a0/g, ' ')
      .split(/\r?\n+/)
      .map(s => s.replace(/\s+/g, ' ').trim())
      .filter(Boolean);
  }

  function fmtMetaLine(label, value, color) {
    const lbl = color ? `[color=${color}]${label}[/color]` : label;
    if (value === null) return `[b]${lbl}:[/b]`;
    return `[b]${lbl}:[/b] ${value || '‚Äî'}`;
  }

  function kz_isOffensiveByAxes(sentVec) {
    const axeIdx = UNIT_KEYS.indexOf('axe');
    if (axeIdx < 0 || !sentVec) return false;
    return (sentVec[axeIdx] || 0) >= 100;
  }

  function fmtSpyAttackLine(attName, sentVec) {
    const spyIdx = UNIT_KEYS.indexOf('spy');
    const spyCount = spyIdx >= 0 ? (sentVec?.[spyIdx] || 0) : 0;
    return `[b][unit]spy[/unit] ${T.attackOn}:[/b] ${attName || T.unknown}${spyCount > 0 ? ` | [unit]spy[/unit] ${spyCount}` : ''}`;
  }

  function kz_pushDefMetaLines(lines, defMeta) {
    if (defMeta.upgrades.length) {
      lines.push(fmtMetaLine(T.upgrades, null, '#6a1b9a'));
      for (const up of defMeta.upgrades) lines.push(`- ${up}`);
    }
    for (const s of defMeta.siege) lines.push(fmtMetaLine(T.siegeDamage, s, '#ef6c00'));
  }

  function kz_extractDefenderMetaDoc(doc) {
    const out = { upgrades: [], siege: [] };
    const rows = Array.from(doc.querySelectorAll('#attack_info_def tr'));
    for (const tr of rows) {
      const cells = tr.querySelectorAll('th, td');
      if (cells.length < 2) continue;
      const key = (cells[0].textContent || '').replace(/\s+/g, ' ').trim().replace(/:$/, '');
      const valRaw = (cells[1].textContent || '').trim();
      if (!key || !valRaw) continue;

      if (/^Vylep≈°en√≠$/i.test(key)) {
        const lines = kz_cleanTextLines(valRaw);
        if (lines.length) out.upgrades.push(...lines);
      }

      if (/^≈†koda vznikl√°/i.test(key)) {
        const val = kz_cleanTextLines(valRaw).join(' | ');
        if (val) out.siege.push(`${key}: ${val}`);
      }
    }
    return out;
  }

  function kz_extractDefenderMetaPage() {
    return kz_extractDefenderMetaDoc(document);
  }
  async function kz_processReportHTML(html) {
    const doc = new DOMParser().parseFromString(html, 'text/html');
    const getTxt = (sel) => (doc.querySelector(sel)?.textContent || '').trim();

    const attName = getTxt('#attack_info_att > tbody > tr:nth-child(1) > th:nth-child(2) > a');
    const defName = getTxt('#attack_info_def > tbody > tr:nth-child(1) > th:nth-child(2) > a');

    const iAmDef = (defName === ME);
    const iAmAtt = (attName === ME);

    let side = null;
    if (iAmDef && !iAmAtt) side = 'att';
    else if (iAmAtt && !iAmDef) side = 'def';
    else return;

    const hrefSel = side === 'att'
      ? '#attack_info_att > tbody > tr:nth-child(2) > td:nth-child(2) a[href*="screen=info_village"][href*="id="]'
      : '#attack_info_def > tbody > tr:nth-child(2) > td:nth-child(2) a[href*="screen=info_village"][href*="id="]';

    const href = doc.querySelector(hrefSel)?.getAttribute('href') || '';
    const targetId = (href.match(/[?&]id=(\d+)/) || [])[1];
    if (!targetId) return;

    const attRow2 = kz_parseVecFromUnitsTableDoc(doc, '#attack_info_att_units', 2);
    const attRow3 = kz_parseVecFromUnitsTableDoc(doc, '#attack_info_att_units', 3);
    const defRow2 = kz_parseVecFromUnitsTableDoc(doc, '#attack_info_def_units', 2);
    const defRow3 = kz_parseVecFromUnitsTableDoc(doc, '#attack_info_def_units', 3);

    const row2 = side === 'att' ? attRow2 : defRow2;
    const row3 = side === 'att' ? attRow3 : defRow3;
    const surv = (row2 && row3) ? vecSub(row2, row3) : null;

    let away = null;
    if (side === 'def') away = kz_parseSpyAwayVecDoc(doc);

    const defMeta = kz_extractDefenderMetaDoc(doc);

    const lines = [];
    let headerVecForClass = row2 || attRow2 || [];

    if (iAmDef && side === 'att') {
      if (!row2 || !row3) return;
      if (vecEqual(row2, row3)) {
        if (!isAllZero(row3)) lines.push(fmtLine(T.died100, row3));
      } else {
        if (!isAllZero(row2)) lines.push(fmtLine(T.sent, row2));
        if (!isAllZero(row3)) lines.push(fmtLine(T.died, row3));
        if (surv && !isAllZero(surv)) lines.push(fmtLine(T.survived, surv));
      }
    } else if (iAmAtt && side === 'def') {
      const isOffAttack = kz_isOffensiveByAxes(attRow2);
      const isSpyAttack = !isOffAttack;
      if (isSpyAttack) lines.push(fmtSpyAttackLine(defName, attRow2));
      else lines.push(fmtMetaLine(T.attackOn, defName || T.unknown, '#455a64'));

      if (isSpyAttack) {
        if (row2 && !isAllZero(row2)) lines.push(fmtLine(T.home, row2));
        if (away && !isAllZero(away)) lines.push(fmtLine(T.away, away));
      } else if (row2 && row3) {
        if (!isAllZero(row2)) lines.push(fmtLine(T.home, row2));
        if (!isAllZero(row3)) lines.push(fmtLine(T.died, row3));
        if (surv && !isAllZero(surv)) lines.push(fmtLine(T.survived, surv));
        if (away && !isAllZero(away)) lines.push(fmtLine(T.away, away));
      } else if (attRow2 && attRow3) {
        const mySurv = vecSub(attRow2, attRow3);
        if (!isAllZero(attRow3)) lines.push(fmtLine(T.died, attRow3));
        if (!isAllZero(mySurv)) lines.push(fmtLine(T.survived, mySurv));
        lines.push(fmtMetaLine(T.noDefenderUnits, '‚Äî', '#616161'));
        headerVecForClass = attRow2;
      }

      kz_pushDefMetaLines(lines, defMeta);

      headerVecForClass = headerVecForClass || row2 || attRow2 || [];
    }

    if (!lines.length) return;

    const battleDate = kz_getBattleDateTextFromDoc(doc);
    const attackSize = kz_attackSizeFromDoc(doc);
    const headerInfo = classify(headerVecForClass);
    const newBlock = buildNoteBlockWithForcedDate(headerInfo, lines, null, battleDate, attackSize);

    const decided = await kz_decideMerge(targetId, newBlock);

    await new Promise((resolve) => {
      apiNoteEdit(targetId, decided.note)
        .done(() => {
          UI.SuccessMessage(decided.mode === 'overwrite' ? T.noteOverwritten : T.noteAppended, 1200);
          resolve();
        })
        .fail(() => {
          UI.ErrorMessage('KZ: Nepovedlo se ulo≈æit pozn√°mku (API).', 2500);
          resolve();
        });
    });
  }

  async function kz_runBatchFromOverview() {
    const urls = kz_getSelectedReportUrlsFromOverview();
    if (!urls.length) {
      UI.ErrorMessage('KZ: Oznaƒç alespo≈à 1 oznamku (checkbox).', 4000);
      return;
    }

    let stop = false;

    const $box = $(`
      <div style="padding:10px">
        <div style="font-weight:700">KZ Batch ‚Äì Auto pozn√°mky</div>
        <div style="margin-top:6px">Vybr√°no: <b>${urls.length}</b></div>

        <div style="margin-top:8px">
          Delay mezi reporty:
          <input id="kz_batch_delay" type="number" min="200" step="100" value="900" style="width:90px"> ms
        </div>

        <div id="kz_batch_status" style="margin-top:10px">P≈ôipraveno‚Ä¶</div>

        <div style="margin-top:10px">
          <button class="btn btn-confirm-yes" id="kz_batch_start">Start</button>
          <button class="btn" id="kz_batch_stop" style="margin-left:6px">Stop</button>
        </div>
      </div>
    `);

    Dialog.show('kz_batch_notes', $box);

    $box.find('#kz_batch_stop').on('click', () => { stop = true; });

    $box.find('#kz_batch_start').on('click', async () => {
      const $status = $box.find('#kz_batch_status');
      const delayMs = Math.max(200, parseInt($box.find('#kz_batch_delay').val(), 10) || 900);

      $status.text(`Naƒç√≠t√°m reporty pro ≈ôazen√≠ podle ƒçasu boje‚Ä¶ (0/${urls.length})`);

      const items = [];
      for (let i = 0; i < urls.length; i++) {
        if (stop) { $status.text('Zastaveno.'); return; }

        $status.text(`Naƒç√≠t√°m reporty pro ≈ôazen√≠ podle ƒçasu boje‚Ä¶ (${i + 1}/${urls.length})`);

        try {
          const html = await (await fetch(urls[i], { credentials: 'include' })).text();
          const doc = new DOMParser().parseFromString(html, 'text/html');
          const battleDate = kz_getBattleDateTextFromDoc(doc);
          const ms = kz_parseBattleDateToMs(battleDate);

          items.push({
            url: urls[i],
            html,
            battleDate,
            ms: Number.isFinite(ms) ? ms : Number.POSITIVE_INFINITY,
          });
        } catch (e) {
          console.error(e);
          items.push({ url: urls[i], html: null, battleDate: '', ms: Number.POSITIVE_INFINITY });
        }
      }

      items.sort((a, b) => {
        if (a.ms !== b.ms) return a.ms - b.ms;
        return String(a.url).localeCompare(String(b.url));
      });

      for (let i = 0; i < items.length; i++) {
        if (stop) { $status.text('Zastaveno.'); return; }

        const it = items[i];
        $status.text(`Zpracov√°v√°m ${i + 1}/${items.length}‚Ä¶ (${it.battleDate || 'ƒças boje ?'})`);

        try {
          if (it.html) await kz_processReportHTML(it.html);
        } catch (e) {
          console.error(e);
        }

        await new Promise(r => setTimeout(r, delayMs));
      }

      $status.text('Hotovo.');
      UI.SuccessMessage('KZ: Batch dokonƒçen', 2500);
    });
  }

  async function runForSide(side) {
    const { attName, defName, attId, defId } = getNamesAndVillageIds();

    const iAmDef = (defName === ME);
    const iAmAtt = (attName === ME);

    const targetId = side === 'att' ? attId : defId;
    const attRow2 = parseVecFromUnitsTable('#attack_info_att_units', 2);
    const attRow3 = parseVecFromUnitsTable('#attack_info_att_units', 3);
    const defRow2 = parseVecFromUnitsTable('#attack_info_def_units', 2);
    const defRow3 = parseVecFromUnitsTable('#attack_info_def_units', 3);

    const row2 = side === 'att' ? attRow2 : defRow2;
    const row3 = side === 'att' ? attRow3 : defRow3;
    const surv = (row2 && row3) ? vecSub(row2, row3) : null;

    let away = null;
    if (side === 'def') away = kz_parseSpyAwayVecPage();

    const defMeta = kz_extractDefenderMetaPage();

    const lines = [];
    let headerVecForClass = row2 || attRow2 || [];

    if (iAmDef && side === 'att') {
      if (!row2 || !row3) {
        UI.ErrorMessage('KZ: Nena≈°el jsem ≈ô√°dky jednotek (Poƒçet/Ztr√°ty).', 4000);
        return;
      }
      if (vecEqual(row2, row3)) {
        if (!isAllZero(row3)) lines.push(fmtLine(T.died100, row3));
      } else {
        if (!isAllZero(row2)) lines.push(fmtLine(T.sent, row2));
        if (!isAllZero(row3)) lines.push(fmtLine(T.died, row3));
        if (surv && !isAllZero(surv)) lines.push(fmtLine(T.survived, surv));
      }
    } else if (iAmAtt && side === 'def') {
      const isOffAttack = kz_isOffensiveByAxes(attRow2);
      const isSpyAttack = !isOffAttack;
      if (isSpyAttack) lines.push(fmtSpyAttackLine(defName, attRow2));
      else lines.push(fmtMetaLine(T.attackOn, defName || T.unknown, '#455a64'));

      if (isSpyAttack) {
        if (row2 && !isAllZero(row2)) lines.push(fmtLine(T.home, row2));
        if (away && !isAllZero(away)) lines.push(fmtLine(T.away, away));
      } else if (row2 && row3) {
        if (!isAllZero(row2)) lines.push(fmtLine(T.home, row2));
        if (!isAllZero(row3)) lines.push(fmtLine(T.died, row3));
        if (surv && !isAllZero(surv)) lines.push(fmtLine(T.survived, surv));
        if (away && !isAllZero(away)) lines.push(fmtLine(T.away, away));
      } else if (attRow2 && attRow3) {
        const mySurv = vecSub(attRow2, attRow3);
        if (!isAllZero(attRow3)) lines.push(fmtLine(T.died, attRow3));
        if (!isAllZero(mySurv)) lines.push(fmtLine(T.survived, mySurv));
        lines.push(fmtMetaLine(T.noDefenderUnits, '‚Äî', '#616161'));
        headerVecForClass = attRow2;
      }

      kz_pushDefMetaLines(lines, defMeta);

      headerVecForClass = headerVecForClass || row2 || attRow2 || [];
    } else {
      if (row2 && !isAllZero(row2)) lines.push(fmtLine('Stav', row2));
      if (row3 && !isAllZero(row3)) lines.push(fmtLine(T.died, row3));
      if (surv && !isAllZero(surv)) lines.push(fmtLine(T.survived, surv));
      if (away && !isAllZero(away)) lines.push(fmtLine(T.away, away));
    }

    if (!lines.length) {
      UI.ErrorMessage('KZ: V reportu nejsou data k z√°pisu.', 3000);
      return;
    }

    const attackSize = kz_attackSizeFromPage();
    const headerInfo = classify(headerVecForClass);
    const newBlock = buildNoteBlock(headerInfo, lines, null, attackSize);

    try {
      const decided = await kz_decideMerge(targetId, newBlock);
      apiNoteEdit(targetId, decided.note)
        .done(() => UI.SuccessMessage(decided.mode === 'overwrite' ? T.noteOverwritten : T.noteAppended, 2500))
        .fail(() => UI.ErrorMessage('KZ: Nepovedlo se ulo≈æit pozn√°mku (API).', 4000));
    } catch (e) {
      console.error(e);
      UI.ErrorMessage('KZ: Chyba p≈ôi ƒçten√≠ existuj√≠c√≠ pozn√°mky / merge.', 4000);
    }
  }

  function start() {
    if (kz_isReportOverviewPage()) {
      return kz_runBatchFromOverview();
    }

    if (!verifyReportPage()) return;

    const { attName, defName } = getNamesAndVillageIds();
    const iAmDef = (defName === ME);
    const iAmAtt = (attName === ME);

    if (iAmDef && !iAmAtt) return runForSide('att');
    if (iAmAtt && !iAmDef) return runForSide('def');

    const box = $('<div class="center"></div>').append(
      $('<div class="center"></div>').text(T.chooseSide),
      $('<div class="center" style="margin-top:10px;"></div>').append(
        $('<button class="btn btn-confirm-yes atk" style="margin-right:10px;"></button>').text(T.attacker),
        $('<button class="btn btn-confirm-yes def"></button>').text(T.defender)
      )
    );

    Dialog.show('kz_report_note', box);
    box.find('button.atk').on('click', () => { Dialog.close(); runForSide('att'); });
    box.find('button.def').on('click', () => { Dialog.close(); runForSide('def'); });
  }

  start();
})();


